Conclusions

When I dug into this query to understand it better, subject to the limitation that I wasn't able to test with it as I would have liked, I arrived at a question as to what the intended results are. The use of a LEFT JOIN on dirsvcs.dir_email implies that we're happy to have the query output some records in which the email information is null. But there are WHERE clauses that restrict the output to cases in which dir_email.mail is not null and, transformed to lowercase, doesn't end in 'cu.edu'.
To complete this analysis, I made the assumption that we do not wish to output records in which email is null. I modified the query accordingly and put the result in 'my_query.sql'.
- I changed the LEFT JOIN on dir_email to an INNER JOIN.
- I moved all filtering clauses on dir_email to the WHERE clause and ordered them simplest first for efficiency.
- I moved the filtering conditions on dp.primaryaffiliation to the WHERE CLAUSE. To me, that makes the query more readable. I hope it's more efficient as well, but I would need to investigate that.

To reduce the overhead of the embedded CASE statements, I would be inclined to create and join an additional table that maps the combination of dp.primaryaffiliation, daf.edupersonaffiliation, and daf.description to the intended value of person_type.  

(I retained the version I'd simply reformatted as 'query_reformatted.sql'.)



Here are some thoughts I recorded as I went along:


What is it doing, as written?

INNER JOIN of dir_person (dp) to dir_affiliation (daf) on uuid:
This a record for each dir_person in which the uuid is matched to the uuid of 1 or more records in dir_affiliation. My guess is that the unique key of dir_person is (uuid), and the unique key of dir_affiliation is (uuid, edupersonaffiliation). If multiple dir_affiliation records match a record in dir_person, the join outputs multiple records with the same uuid, each with a different edupersonaffiliation.
Filtering conditions follow each AND in this ON clause. Since this is an INNER JOIN, these conditions prevent any rows that don't meet the filtering conditions from appearing in the output. The query can be made more compact, and to me more readable, by using the NOT IN (list) construct to reduce the number of AND's. Among these, we're eliminating a dp.primaryaffiliation of 'Affiliate', which cancels the utility of two of the WHEN clauses above. 

LEFT JOIN of records output by INNER JOIN and dir_email on uuid:
The JOIN itself would leave the number of records output unchanged, and only append information from dir_email where there is a match in uuid. The filtering clauses embedded in this JOIN/ON clause would prevent dir_email.mail from appearing in the query output, unless it is not null and its mail_flag = 'M'. Where these conditions are not met, the output 'email' value would be null.

WHERE clause
The WHERE clause allows records to be output only if the following are true:
- primaryaffiliation != 'Student' and lower(de.mail) not like '%cu.edu' - OR - dp.primaryaffiliation = 'Student' and record(s) exist in dir_acad_career that have the same uuid
- de.mail is not null
- lower(de.mail) doesn't end in 'cu.edu';
The LEFT JOIN already caused emails not to be displayed if they are null, which I think is unneccessary, since the use of the LEFT JOIN implies that we are happy to output null emails.  


Initial thoughts

So many case statements make the query difficult to read. I find that adding appropriate line feeds and indentation helps clarify what's happening.
To me, it would clarify this query if one were to store the relationshipe of dp.primaryaffiliation to "person_type" in a separate table and join that table.
My sense is that the query would be more efficient if an effort were made to reduce the volume of data potentially participating in the joins earlier on, possibly through the user of a sub-select. But I would want to test to verify that, and that the results remained unchanged.

